<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <style>
    * {
      box-sizing: border-box;
      --ash-gray: #c9cebdff;
      --ash-gray-2: #b2bcaaff;
      --xanadu: #838e83ff;
      --dim-gray: #6c6061ff;
      --rose-ebony: #64403eff;
      font-family: "Lucida Sans", sans-serif;
    }
    .column {
      float: left;
      padding: 10px;
    }
    .left {
      width: 75%;
      height: 90vh;
      overflow: auto;
      background-color: var(--rose-ebony);
    }
    .right {
      width: 25%;
    }
    /* Clear floats after the columns */
    .row:after {
      content: "";
      display: table;
      clear: both;
    }
    .button {
      border: none;
      color: white;
      padding: 15px 32px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      margin: 4px 2px;
      cursor: pointer;
      width: 100%;
    }
    .button1 {background-color: var(--xanadu);} /* Green */
    
    </style>
  <title>Retro</title>
</head>
<body style="background-color: var(--ash-gray)" onkeypress="handleKeypress(m, totalDecks)">
  <div class="row">
    <div class="column left" id="monitorColumn">
      <p id="monitor"; style="color:white; font-size: larger"></p>
    </div>

    <div class="column right">
      <button class="button button1">Green</button>
    </div>

  </div>

  <script>
    class Card {
      constructor(text) {
        this.text = text;
      }
    }

    class Deck {
      constructor(deckData,shuffleEachRound) {
        this.cards = [];
        this.deckData = deckData;
        this.shuffleEachRound = shuffleEachRound;
        this.createDeck();
        this.shuffleDeck();
      }

      createDeck() {
        for (let i = 0; i < this.deckData.length; i = i+2) {
          for (let j = 0; j < this.deckData[i]; j++) {
            this.cards.push(new Card(this.deckData[i+1]));            
          }
        }
      }

      shuffleDeck() {
       let location1, location2, tmp;
       for (let i = 0; i < 1000; i++) {
           location1 = Math.floor((Math.random() * this.cards.length));
           location2 = Math.floor((Math.random() * this.cards.length));
           tmp = this.cards[location1];
           this.cards[location1] = this.cards[location2];
           this.cards[location2] = tmp;
        }
      }

      drawCard() {
        // TODO: Check for no cards left in deck.
        if (this.cards.length == 0) {
          this.createDeck(this.deckData);
          this.shuffleDeck();
          alert ("Deck shuffled.");
        }
        return this.cards.pop();
      }
    }

    class Monitor {
      constructor(monitorElement) {
        this.element = monitorElement;
        this.reset();
      }

      refresh() {
        this.element.innerHTML = this.output;
      }

      reset() {
        this.output = "* Ready *<br>---<br> ";
        this.refresh();
      }

      write(text) {
        this.output = this.output.concat(text);
        this.output = this.output.concat("<br>---<br>")
        this.refresh();
        let x = this.element.parentNode.id;
        document.getElementById(x).scrollTop += 500;
      }
    }

    class Dashboard {
      constructor(monitor,totalDecks) {
        this.monitor = monitor;
        this.totalDecks = totalDecks;
      }
      startNewGame() {
        this.monitor.write("New game started.");
        this.round = 0;
        this.playerHasPriority = false;
        this.phase = 0;
        this.maxPhase = 11;
        this.phaseArray = [];

        this.shuffleDecks();
        this.rollPriority();
        this.displayInfo();

      }
      shuffleDecks(){
        // Rebuild and shuffle each deck that has the shuffleEachRound flag set.
        for (let i = 0; i < this.totalDecks.length; i++){
          if (this.totalDecks[i].shuffleEachRound == true){
            this.totalDecks[i].createDeck();
            this.totalDecks[i].shuffleDeck();
          }
        }

      }
      displayInfo() {
        let message = "Current round: " + this.round + "<br>" + this.phaseArray[this.phase];
        this.monitor.write(message);
      }
      processNextPhase() {
        this.phase++;
        if (this.phase > this.maxPhase){
          this.processNextRound();
        }
        this.displayInfo();
      }
      processNextRound() {
        this.phase = 0;
        this.round++;
        this.rollPriority();
        this.shuffleDecks();
        this.monitor.write("*** NEW ROUND ***")
      }
      rollPriority() {
        let playerPriorityRound = [
          'HERO PHASE<br>\
            Gain a Command Point from your general. Use a Heroic Ability. Wizards can use magic.',
          'MOVEMENT PHASE<br>\
            Move, run or retreat units.',
          "SHOOTING PHASE<br>\
            Units shoot with missile weapons.",
          "CHARGE PHASE<br>\
            Units can attempt to charge enemy units.",
          'COMBAT PHASE (Player priority)<br>\
            Starting with the player, take turns to fight with units using melee weapons. \
            Draw an ability for each AI unit that fights.',
          'BATTLESHOCK PHASE<br>\
            Test the resolve of depleted units.',
          'END OF PLAYER TURN<br>\
            Clean up.',
          'ACTION PHASE<br>\
            All AI Heroes gain 1 react token, to a maximum of 1.\
            Take turns activating the AI units, starting with the unit with the fewest models in it. \
            Draw an ability for each AI unit that shoots.',
          'COMBAT PHASE (AI priority)<br>\
            Starting with the AI, take turns to fight with units using melee weapons. \
            Draw an ability for each AI unit that fights.',
          'BATTLESHOCK PHASE<br>\
            Test the resolve of depleted units.',
          'END OF AI TURN<br>\
            Clean up.',
          'END OF ROUND<br>\
            Consult battleplan and/or resolve special events.'
        ]
        let aiPriorityRound = [
          'ACTION PHASE<br>\
            All AI Heroes gain 1 react token, to a maximum of 1.\
            Take turns activating the AI units, starting with the unit with the fewest models in it. \
            Draw an ability for each AI unit that shoots.',
            'COMBAT PHASE (AI priority)<br>\
            Starting with the AI, take turns to fight with units using melee weapons. \
            Draw an ability for each AI unit that fights.',
          'BATTLESHOCK PHASE<br>\
            Test the resolve of depleted units.',
          'END OF AI TURN<br>\
            Clean up.',
          'HERO PHASE<br>\
            Gain a Command Point from your general. Use a Heroic Ability. Wizards can use magic.',
          'MOVEMENT PHASE<br>\
            Move, run or retreat units.',
          "SHOOTING PHASE<br>\
            Units shoot with missile weapons.",
          "CHARGE PHASE<br>\
            Units can attempt to charge enemy units.",
          'COMBAT PHASE (Player priority)<br>\
            Starting with the player, take turns to fight with units using melee weapons. \
            Draw an ability for each AI unit that fights.',
          'BATTLESHOCK PHASE<br>\
            Test the resolve of depleted units.',
          'END OF PLAYER TURN<br>\
            Clean up.',
          'END OF ROUND<br>\
            Consult battleplan and/or resolve special events.'
        ]
        
        let x = Math.random();
        if (x < .5) {
          this.playerHasPriority = false;
          this.phaseArray = aiPriorityRound;  
        } else {
          this.playerHasPriority = true;
          this.phaseArray = playerPriorityRound;

        }
      }
    }

    let actionDeckData = [
          2, 'RUSH<br>\
              This unit makes an Advance action. Then draw another card.',
          4, 'ADVANCE<br>\
              This unit makes an Advance action.',
          2, 'ENGAGE<br>\
              This unit makes an Engage action.',
          2, 'FORTIFY<br>\
              This unit makes a Fortify action.',
          1, 'RECOVER<br>\
              This unit Recovers D3 wounds. Then draw another card.',
    ];

    let abilityDeckData = [
      6, 'NOTHING<br>\
          The unit does not use an ability.',
      3, 'ONSLAUGHT<br>\
          Reroll failed hit rolls for this unit.',
      3, "FURY<br>\
          Increase this unit's Rend characteristic by 1.",
      3, "BESERK<br>\
          All hit rolls of 6+ inflict D3 hits on the target unit",
      3, 'FORTITUDE<br>\
          Recover D3 wounds on this unit before attacking.',
      3, 'DEATHSTRIKE<br>\
      Inflict D3 mortal wounds to the target unit before attacking.'
    ];

    let eventDeckData = [
      6, 'NOTHING<br>\
          Nothing happens.',
      3, 'INSPIRATION<br>\
          Pick an AI unit at random. That unit makes an action.',
      1, 'RAMPAGE<br>\
          Pick an AI unit within 3" of an enemy unit at random. That unit attacks.'
      ];

    let m = new Monitor(document.getElementById("monitor"));
    let actionDeck = new Deck(actionDeckData, true);
    let abilityDeck = new Deck(abilityDeckData, true);
    let eventDeck = new Deck(eventDeckData, false);
    let totalDecks = [actionDeck,abilityDeck,eventDeck];
    let battleDashboard = new Dashboard(m, totalDecks);
    battleDashboard.startNewGame();

    function handleKeypress(monitor, decks){
      let x = event.keyCode;
      let newCard = {};
      //console.log("Key pressed!" + x);
      switch(x) {
        case 49: // 1
          newCard = decks[0].drawCard();
          monitor.write(newCard.text);
        break;
        case 50: // 2
          newCard = decks[1].drawCard();
          monitor.write(newCard.text);
        break;
        case 51: // 3
          newCard = decks[2].drawCard();
          monitor.write(newCard.text);
        break;

        case 110: // n
          battleDashboard.startNewGame();
        break;

        case 46: // .
          battleDashboard.processNextPhase();
        break;

        default:
          monitor.write("Invalid key: " + x);
      }
    }

  </script>
</body>
</html>
